[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar WebApp = Package.webapp.WebApp;\nvar main = Package.webapp.main;\nvar WebAppInternals = Package.webapp.WebAppInternals;\nvar _ = Package.underscore._;\n\n/* Package-scope variables */\nvar Spiderable;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                 //\n// packages/spiderable/spiderable.js                                                                               //\n//                                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                   //\nSpiderable = {};                                                                                                   // 1\n                                                                                                                   // 2\n                                                                                                                   // 3\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                 //\n// packages/spiderable/spiderable_server.js                                                                        //\n//                                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                   //\nvar fs = Npm.require('fs');                                                                                        // 1\nvar child_process = Npm.require('child_process');                                                                  // 2\nvar querystring = Npm.require('querystring');                                                                      // 3\nvar urlParser = Npm.require('url');                                                                                // 4\n                                                                                                                   // 5\n// list of bot user agents that we want to serve statically, but do                                                // 6\n// not obey the _escaped_fragment_ protocol. The page is served                                                    // 7\n// statically to any client whos user agent matches any of these                                                   // 8\n// regexps. Users may modify this array.                                                                           // 9\n//                                                                                                                 // 10\n// An original goal with the spiderable package was to avoid doing                                                 // 11\n// user-agent based tests. But the reality is not enough bots support                                              // 12\n// the _escaped_fragment_ protocol, so we need to hardcode a list                                                  // 13\n// here. I shed a silent tear.                                                                                     // 14\nSpiderable.userAgentRegExps = [                                                                                    // 15\n  /^facebookexternalhit/i,                                                                                         // 16\n  /^linkedinbot/i,                                                                                                 // 17\n  /^twitterbot/i,                                                                                                  // 18\n  /^slackbot-linkexpanding/i                                                                                       // 19\n];                                                                                                                 // 20\n                                                                                                                   // 21\n// how long to let phantomjs run before we kill it (and send down the                                              // 22\n// regular page instead). Users may modify this number.                                                            // 23\nSpiderable.requestTimeoutMs = 15*1000;                                                                             // 24\n// maximum size of result HTML. node's default is 200k which is too                                                // 25\n// small for our docs.                                                                                             // 26\nvar MAX_BUFFER = 5*1024*1024; // 5MB                                                                               // 27\n                                                                                                                   // 28\n// Exported for tests.                                                                                             // 29\nSpiderable._urlForPhantom = function (siteAbsoluteUrl, requestUrl) {                                               // 30\n  // reassembling url without escaped fragment if exists                                                           // 31\n  var parsedUrl = urlParser.parse(requestUrl);                                                                     // 32\n  var parsedQuery = querystring.parse(parsedUrl.query);                                                            // 33\n  var escapedFragment = parsedQuery['_escaped_fragment_'];                                                         // 34\n  delete parsedQuery['_escaped_fragment_'];                                                                        // 35\n                                                                                                                   // 36\n  var parsedAbsoluteUrl = urlParser.parse(siteAbsoluteUrl);                                                        // 37\n  // If the ROOT_URL contains a path, Meteor strips that path off of the                                           // 38\n  // request's URL before we see it. So we concatenate the pathname from                                           // 39\n  // the request's URL with the root URL's pathname to get the full                                                // 40\n  // pathname.                                                                                                     // 41\n  if (parsedUrl.pathname.charAt(0) === \"/\") {                                                                      // 42\n    parsedUrl.pathname = parsedUrl.pathname.substring(1);                                                          // 43\n  }                                                                                                                // 44\n  parsedAbsoluteUrl.pathname = urlParser.resolve(parsedAbsoluteUrl.pathname,                                       // 45\n                                                 parsedUrl.pathname);                                              // 46\n  parsedAbsoluteUrl.query = parsedQuery;                                                                           // 47\n  // `url.format` will only use `query` if `search` is absent                                                      // 48\n  parsedAbsoluteUrl.search = null;                                                                                 // 49\n                                                                                                                   // 50\n  if (escapedFragment !== undefined && escapedFragment !== null && escapedFragment.length > 0) {                   // 51\n    parsedAbsoluteUrl.hash = '!' + decodeURIComponent(escapedFragment);                                            // 52\n  }                                                                                                                // 53\n                                                                                                                   // 54\n  return urlParser.format(parsedAbsoluteUrl);                                                                      // 55\n};                                                                                                                 // 56\n                                                                                                                   // 57\nvar PHANTOM_SCRIPT = Assets.getText(\"phantom_script.js\");                                                          // 58\n                                                                                                                   // 59\nWebApp.connectHandlers.use(function (req, res, next) {                                                             // 60\n  // _escaped_fragment_ comes from Google's AJAX crawling spec:                                                    // 61\n  // https://developers.google.com/webmasters/ajax-crawling/docs/specification                                     // 62\n  if (/\\?.*_escaped_fragment_=/.test(req.url) ||                                                                   // 63\n      _.any(Spiderable.userAgentRegExps, function (re) {                                                           // 64\n        return re.test(req.headers['user-agent']); })) {                                                           // 65\n                                                                                                                   // 66\n    var url = Spiderable._urlForPhantom(Meteor.absoluteUrl(), req.url);                                            // 67\n                                                                                                                   // 68\n    // This string is going to be put into a bash script, so it's important                                        // 69\n    // that 'url' (which comes from the network) can neither exploit phantomjs                                     // 70\n    // or the bash script. JSON stringification should prevent it from                                             // 71\n    // exploiting phantomjs, and since the output of JSON.stringify shouldn't                                      // 72\n    // be able to contain newlines, it should be unable to exploit bash as                                         // 73\n    // well.                                                                                                       // 74\n    var phantomScript = \"var url = \" + JSON.stringify(url) + \";\" +                                                 // 75\n          PHANTOM_SCRIPT;                                                                                          // 76\n                                                                                                                   // 77\n    // Allow override of phantomjs args via env var                                                                // 78\n    // We use one env var to try to keep env-var explosion under control.                                          // 79\n    // We're not going to document this unless it is actually needed;                                              // 80\n    // (if you find yourself needing this please let us know the use case!)                                        // 81\n    var phantomJsArgs = process.env.METEOR_PKG_SPIDERABLE_PHANTOMJS_ARGS || '';                                    // 82\n                                                                                                                   // 83\n    // Default image loading to off (we don't need images)                                                         // 84\n    if (phantomJsArgs.indexOf(\"--load-images=\") === -1) {                                                          // 85\n      phantomJsArgs += \" --load-images=no\";                                                                        // 86\n    }                                                                                                              // 87\n                                                                                                                   // 88\n    // POODLE means SSLv3 is being turned off everywhere.                                                          // 89\n    // phantomjs currently defaults to SSLv3, and won't use TLS.                                                   // 90\n    // Use --ssl-protocol to set the default to TLSv1                                                              // 91\n    // (another option would be 'any', but really, we want to say >= TLSv1)                                        // 92\n    // More info: https://groups.google.com/forum/#!topic/meteor-core/uZhT3AHwpsI                                  // 93\n    if (phantomJsArgs.indexOf(\"--ssl-protocol=\") === -1) {                                                         // 94\n      phantomJsArgs += \" --ssl-protocol=TLSv1\";                                                                    // 95\n    }                                                                                                              // 96\n                                                                                                                   // 97\n    // Run phantomjs.                                                                                              // 98\n    //                                                                                                             // 99\n    // Use '/dev/stdin' to avoid writing to a temporary file. We can't                                             // 100\n    // just omit the file, as PhantomJS takes that to mean 'use a                                                  // 101\n    // REPL' and exits as soon as stdin closes.                                                                    // 102\n    //                                                                                                             // 103\n    // However, Node 0.8 broke the ability to open /dev/stdin in the                                               // 104\n    // subprocess, so we can't just write our string to the process's stdin                                        // 105\n    // directly; see https://gist.github.com/3751746 for the gory details. We                                      // 106\n    // work around this with a bash heredoc. (We previous used a \"cat |\"                                           // 107\n    // instead, but that meant we couldn't use exec and had to manage several                                      // 108\n    // processes.)                                                                                                 // 109\n    child_process.execFile(                                                                                        // 110\n      '/bin/bash',                                                                                                 // 111\n      ['-c',                                                                                                       // 112\n       (\"exec phantomjs \" + phantomJsArgs + \" /dev/stdin <<'END'\\n\" +                                              // 113\n        phantomScript + \"END\\n\")],                                                                                 // 114\n      {timeout: Spiderable.requestTimeoutMs, maxBuffer: MAX_BUFFER},                                               // 115\n      function (error, stdout, stderr) {                                                                           // 116\n        if (!error && /<html/i.test(stdout)) {                                                                     // 117\n          res.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'});                                        // 118\n          res.end(stdout);                                                                                         // 119\n        } else {                                                                                                   // 120\n          // phantomjs failed. Don't send the error, instead send the                                              // 121\n          // normal page.                                                                                          // 122\n          if (error && error.code === 127)                                                                         // 123\n            Meteor._debug(\"spiderable: phantomjs not installed. Download and install from http://phantomjs.org/\");\n          else                                                                                                     // 125\n            Meteor._debug(\"spiderable: phantomjs failed at \" + url + \":\", error, \"\\nstderr:\", stderr, \"\\nstdout:\", stdout);\n                                                                                                                   // 127\n          next();                                                                                                  // 128\n        }                                                                                                          // 129\n      });                                                                                                          // 130\n  } else {                                                                                                         // 131\n    next();                                                                                                        // 132\n  }                                                                                                                // 133\n});                                                                                                                // 134\n                                                                                                                   // 135\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.spiderable = {\n  Spiderable: Spiderable\n};\n\n})();\n","servePath":"/packages/spiderable.js","sourceMap":{"version":3,"sources":["/packages/spiderable/spiderable.js","/packages/spiderable/spiderable_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA,uH;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yH","file":"/packages/spiderable.js","sourcesContent":["Spiderable = {};\n\n","var fs = Npm.require('fs');\nvar child_process = Npm.require('child_process');\nvar querystring = Npm.require('querystring');\nvar urlParser = Npm.require('url');\n\n// list of bot user agents that we want to serve statically, but do\n// not obey the _escaped_fragment_ protocol. The page is served\n// statically to any client whos user agent matches any of these\n// regexps. Users may modify this array.\n//\n// An original goal with the spiderable package was to avoid doing\n// user-agent based tests. But the reality is not enough bots support\n// the _escaped_fragment_ protocol, so we need to hardcode a list\n// here. I shed a silent tear.\nSpiderable.userAgentRegExps = [\n  /^facebookexternalhit/i,\n  /^linkedinbot/i,\n  /^twitterbot/i,\n  /^slackbot-linkexpanding/i\n];\n\n// how long to let phantomjs run before we kill it (and send down the\n// regular page instead). Users may modify this number.\nSpiderable.requestTimeoutMs = 15*1000;\n// maximum size of result HTML. node's default is 200k which is too\n// small for our docs.\nvar MAX_BUFFER = 5*1024*1024; // 5MB\n\n// Exported for tests.\nSpiderable._urlForPhantom = function (siteAbsoluteUrl, requestUrl) {\n  // reassembling url without escaped fragment if exists\n  var parsedUrl = urlParser.parse(requestUrl);\n  var parsedQuery = querystring.parse(parsedUrl.query);\n  var escapedFragment = parsedQuery['_escaped_fragment_'];\n  delete parsedQuery['_escaped_fragment_'];\n\n  var parsedAbsoluteUrl = urlParser.parse(siteAbsoluteUrl);\n  // If the ROOT_URL contains a path, Meteor strips that path off of the\n  // request's URL before we see it. So we concatenate the pathname from\n  // the request's URL with the root URL's pathname to get the full\n  // pathname.\n  if (parsedUrl.pathname.charAt(0) === \"/\") {\n    parsedUrl.pathname = parsedUrl.pathname.substring(1);\n  }\n  parsedAbsoluteUrl.pathname = urlParser.resolve(parsedAbsoluteUrl.pathname,\n                                                 parsedUrl.pathname);\n  parsedAbsoluteUrl.query = parsedQuery;\n  // `url.format` will only use `query` if `search` is absent\n  parsedAbsoluteUrl.search = null;\n\n  if (escapedFragment !== undefined && escapedFragment !== null && escapedFragment.length > 0) {\n    parsedAbsoluteUrl.hash = '!' + decodeURIComponent(escapedFragment);\n  }\n\n  return urlParser.format(parsedAbsoluteUrl);\n};\n\nvar PHANTOM_SCRIPT = Assets.getText(\"phantom_script.js\");\n\nWebApp.connectHandlers.use(function (req, res, next) {\n  // _escaped_fragment_ comes from Google's AJAX crawling spec:\n  // https://developers.google.com/webmasters/ajax-crawling/docs/specification\n  if (/\\?.*_escaped_fragment_=/.test(req.url) ||\n      _.any(Spiderable.userAgentRegExps, function (re) {\n        return re.test(req.headers['user-agent']); })) {\n\n    var url = Spiderable._urlForPhantom(Meteor.absoluteUrl(), req.url);\n\n    // This string is going to be put into a bash script, so it's important\n    // that 'url' (which comes from the network) can neither exploit phantomjs\n    // or the bash script. JSON stringification should prevent it from\n    // exploiting phantomjs, and since the output of JSON.stringify shouldn't\n    // be able to contain newlines, it should be unable to exploit bash as\n    // well.\n    var phantomScript = \"var url = \" + JSON.stringify(url) + \";\" +\n          PHANTOM_SCRIPT;\n\n    // Allow override of phantomjs args via env var\n    // We use one env var to try to keep env-var explosion under control.\n    // We're not going to document this unless it is actually needed;\n    // (if you find yourself needing this please let us know the use case!)\n    var phantomJsArgs = process.env.METEOR_PKG_SPIDERABLE_PHANTOMJS_ARGS || '';\n\n    // Default image loading to off (we don't need images)\n    if (phantomJsArgs.indexOf(\"--load-images=\") === -1) {\n      phantomJsArgs += \" --load-images=no\";\n    }\n\n    // POODLE means SSLv3 is being turned off everywhere.\n    // phantomjs currently defaults to SSLv3, and won't use TLS.\n    // Use --ssl-protocol to set the default to TLSv1\n    // (another option would be 'any', but really, we want to say >= TLSv1)\n    // More info: https://groups.google.com/forum/#!topic/meteor-core/uZhT3AHwpsI\n    if (phantomJsArgs.indexOf(\"--ssl-protocol=\") === -1) {\n      phantomJsArgs += \" --ssl-protocol=TLSv1\";\n    }\n\n    // Run phantomjs.\n    //\n    // Use '/dev/stdin' to avoid writing to a temporary file. We can't\n    // just omit the file, as PhantomJS takes that to mean 'use a\n    // REPL' and exits as soon as stdin closes.\n    //\n    // However, Node 0.8 broke the ability to open /dev/stdin in the\n    // subprocess, so we can't just write our string to the process's stdin\n    // directly; see https://gist.github.com/3751746 for the gory details. We\n    // work around this with a bash heredoc. (We previous used a \"cat |\"\n    // instead, but that meant we couldn't use exec and had to manage several\n    // processes.)\n    child_process.execFile(\n      '/bin/bash',\n      ['-c',\n       (\"exec phantomjs \" + phantomJsArgs + \" /dev/stdin <<'END'\\n\" +\n        phantomScript + \"END\\n\")],\n      {timeout: Spiderable.requestTimeoutMs, maxBuffer: MAX_BUFFER},\n      function (error, stdout, stderr) {\n        if (!error && /<html/i.test(stdout)) {\n          res.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'});\n          res.end(stdout);\n        } else {\n          // phantomjs failed. Don't send the error, instead send the\n          // normal page.\n          if (error && error.code === 127)\n            Meteor._debug(\"spiderable: phantomjs not installed. Download and install from http://phantomjs.org/\");\n          else\n            Meteor._debug(\"spiderable: phantomjs failed at \" + url + \":\", error, \"\\nstderr:\", stderr, \"\\nstdout:\", stdout);\n\n          next();\n        }\n      });\n  } else {\n    next();\n  }\n});\n"]}}]